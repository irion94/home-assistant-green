"""Home Assistant REST API client.

This module handles communication with the Home Assistant REST API
to execute service calls generated by the AI planning pipeline.

Phase 7: Added retry logic with exponential backoff for reliability.
"""

from __future__ import annotations

import logging
from typing import Any

import httpx
from tenacity import (
    retry,
    stop_after_attempt,
    wait_exponential,
    retry_if_exception_type,
    before_sleep_log,
)

from app.models import Config, HAAction

logger = logging.getLogger(__name__)


class HomeAssistantClient:
    """Client for Home Assistant REST API."""

    def __init__(self, config: Config) -> None:
        """Initialize Home Assistant client.

        Args:
            config: Application configuration
        """
        self.base_url = config.ha_base_url
        self.token = config.ha_token
        self.timeout = config.ha_timeout

    def _get_headers(self) -> dict[str, str]:
        """Get authorization headers for HA API.

        Returns:
            Headers dictionary with authorization token
        """
        return {
            "Authorization": f"Bearer {self.token}",
            "Content-Type": "application/json",
        }

    @retry(
        stop=stop_after_attempt(3),
        wait=wait_exponential(multiplier=1, min=2, max=10),
        retry=retry_if_exception_type((httpx.TimeoutException, httpx.ConnectError)),
        before_sleep=before_sleep_log(logger, logging.WARNING),
    )
    async def call_service(self, action: HAAction) -> dict[str, Any] | None:
        """Execute Home Assistant service call.

        Phase 7: Retries up to 3 times with exponential backoff (2s, 4s, 8s).
        Only retries on timeout/connection errors, not on authentication/4xx errors.

        Args:
            action: Validated HAAction plan to execute

        Returns:
            Response from Home Assistant API, or None if call fails
        """
        if action.action != "call_service" or not action.service:
            logger.warning(f"Invalid action for call_service: {action}")
            return None

        # Parse service string (e.g., "light.turn_on" -> domain="light", service="turn_on")
        try:
            domain, service_name = action.service.split(".", 1)
        except ValueError:
            logger.error(f"Invalid service format: {action.service}")
            return None

        # Build request payload
        payload: dict[str, Any] = {"entity_id": action.entity_id}
        if action.data:
            payload.update(action.data)

        # Build URL
        url = f"{self.base_url}/api/services/{domain}/{service_name}"

        logger.info(f"Calling HA service: {action.service} for {action.entity_id}")
        logger.debug(f"Payload: {payload}")

        try:
            async with httpx.AsyncClient(timeout=self.timeout) as client:
                response = await client.post(
                    url,
                    json=payload,
                    headers=self._get_headers(),
                )
                response.raise_for_status()

            response_data: dict[str, Any] = response.json()
            logger.info(f"HA service call successful: {action.service}")
            logger.debug(f"HA response: {response_data}")

            return response_data

        except httpx.HTTPError as e:
            logger.error(f"HTTP error calling Home Assistant: {e}")
            if hasattr(e, "response") and e.response is not None:
                logger.error(f"Response body: {e.response.text}")
            return None

        except Exception as e:
            logger.error(f"Unexpected error in call_service: {e}")
            return None

    async def call_services(self, actions: list[HAAction]) -> list[dict[str, Any]]:
        """Execute multiple Home Assistant service calls sequentially.

        Args:
            actions: List of HAAction plans to execute

        Returns:
            List of results for each action (success/error status)
        """
        results: list[dict[str, Any]] = []

        for i, action in enumerate(actions):
            try:
                if action.action != "call_service":
                    logger.warning(f"Skipping non-service action at index {i}: {action.action}")
                    results.append({
                        "index": i,
                        "status": "skipped",
                        "service": None,
                        "entity_id": action.entity_id,
                        "error": f"Invalid action type: {action.action}",
                    })
                    continue

                result = await self.call_service(action)

                if result is not None:
                    results.append({
                        "index": i,
                        "status": "success",
                        "service": action.service,
                        "entity_id": action.entity_id,
                        "result": result,
                    })
                    logger.info(f"Scene action {i+1}/{len(actions)} succeeded: {action.service}")
                else:
                    results.append({
                        "index": i,
                        "status": "error",
                        "service": action.service,
                        "entity_id": action.entity_id,
                        "error": "Service call returned None",
                    })
                    logger.warning(f"Scene action {i+1}/{len(actions)} failed: {action.service}")

            except Exception as e:
                results.append({
                    "index": i,
                    "status": "error",
                    "service": action.service if action else None,
                    "entity_id": action.entity_id if action else None,
                    "error": str(e),
                })
                logger.error(f"Exception in scene action {i+1}/{len(actions)}: {e}")

        # Summary log
        success_count = sum(1 for r in results if r["status"] == "success")
        logger.info(f"Scene execution complete: {success_count}/{len(actions)} actions succeeded")

        return results

    async def health_check(self) -> bool:
        """Check if Home Assistant API is accessible.

        Returns:
            True if HA is reachable and authenticated, False otherwise
        """
        url = f"{self.base_url}/api/"

        try:
            async with httpx.AsyncClient(timeout=5.0) as client:
                response = await client.get(url, headers=self._get_headers())
                response.raise_for_status()

            data = response.json()
            logger.info(f"Home Assistant health check OK: {data.get('message')}")
            return True

        except httpx.HTTPError as e:
            logger.error(f"Home Assistant health check failed: {e}")
            return False

        except Exception as e:
            logger.error(f"Unexpected error in health check: {e}")
            return False

    @retry(
        stop=stop_after_attempt(3),
        wait=wait_exponential(multiplier=1, min=2, max=10),
        retry=retry_if_exception_type((httpx.TimeoutException, httpx.ConnectError)),
        before_sleep=before_sleep_log(logger, logging.WARNING),
    )
    async def get_states(self) -> list[dict[str, Any]]:
        """Get all entity states from Home Assistant.

        Phase 7: Retries up to 3 times with exponential backoff.

        Returns:
            List of entity state dictionaries
        """
        url = f"{self.base_url}/api/states"

        try:
            async with httpx.AsyncClient(timeout=self.timeout) as client:
                response = await client.get(url, headers=self._get_headers())
                response.raise_for_status()

            states: list[dict[str, Any]] = response.json()
            logger.info(f"Fetched {len(states)} entity states from Home Assistant")
            return states

        except httpx.HTTPError as e:
            logger.error(f"HTTP error fetching states: {e}")
            return []

        except Exception as e:
            logger.error(f"Unexpected error in get_states: {e}")
            return []

    @retry(
        stop=stop_after_attempt(3),
        wait=wait_exponential(multiplier=1, min=2, max=10),
        retry=retry_if_exception_type((httpx.TimeoutException, httpx.ConnectError)),
        before_sleep=before_sleep_log(logger, logging.WARNING),
    )
    async def get_state(self, entity_id: str) -> dict[str, Any] | None:
        """Get state of a specific entity from Home Assistant.

        Phase 7: Retries up to 3 times with exponential backoff.

        Args:
            entity_id: Entity ID to fetch (e.g., 'sensor.temperature')

        Returns:
            Entity state dictionary or None if not found
        """
        url = f"{self.base_url}/api/states/{entity_id}"

        try:
            async with httpx.AsyncClient(timeout=self.timeout) as client:
                response = await client.get(url, headers=self._get_headers())
                if response.status_code == 404:
                    logger.warning(f"Entity not found: {entity_id}")
                    return None
                response.raise_for_status()

            state: dict[str, Any] = response.json()
            logger.info(f"Fetched state for {entity_id}: {state.get('state')}")
            return state

        except httpx.HTTPError as e:
            logger.error(f"HTTP error fetching state for {entity_id}: {e}")
            return None

        except Exception as e:
            logger.error(f"Unexpected error in get_state: {e}")
            return None
