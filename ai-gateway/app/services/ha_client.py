"""Home Assistant REST API client.

This module handles communication with the Home Assistant REST API
to execute service calls generated by the AI planning pipeline.
"""

from __future__ import annotations

import logging
from typing import Any

import httpx

from app.models import Config, HAAction

logger = logging.getLogger(__name__)


class HomeAssistantClient:
    """Client for Home Assistant REST API."""

    def __init__(self, config: Config) -> None:
        """Initialize Home Assistant client.

        Args:
            config: Application configuration
        """
        self.base_url = config.ha_base_url
        self.token = config.ha_token
        self.timeout = 10.0  # 10 second timeout for HA API calls

    def _get_headers(self) -> dict[str, str]:
        """Get authorization headers for HA API.

        Returns:
            Headers dictionary with authorization token
        """
        return {
            "Authorization": f"Bearer {self.token}",
            "Content-Type": "application/json",
        }

    async def call_service(self, action: HAAction) -> dict[str, Any] | None:
        """Execute Home Assistant service call.

        Args:
            action: Validated HAAction plan to execute

        Returns:
            Response from Home Assistant API, or None if call fails
        """
        if action.action != "call_service" or not action.service:
            logger.warning(f"Invalid action for call_service: {action}")
            return None

        # Parse service string (e.g., "light.turn_on" -> domain="light", service="turn_on")
        try:
            domain, service_name = action.service.split(".", 1)
        except ValueError:
            logger.error(f"Invalid service format: {action.service}")
            return None

        # Build request payload
        payload: dict[str, Any] = {"entity_id": action.entity_id}
        if action.data:
            payload.update(action.data)

        # Build URL
        url = f"{self.base_url}/api/services/{domain}/{service_name}"

        logger.info(f"Calling HA service: {action.service} for {action.entity_id}")
        logger.debug(f"Payload: {payload}")

        try:
            async with httpx.AsyncClient(timeout=self.timeout) as client:
                response = await client.post(
                    url,
                    json=payload,
                    headers=self._get_headers(),
                )
                response.raise_for_status()

            response_data: dict[str, Any] = response.json()
            logger.info(f"HA service call successful: {action.service}")
            logger.debug(f"HA response: {response_data}")

            return response_data

        except httpx.HTTPError as e:
            logger.error(f"HTTP error calling Home Assistant: {e}")
            if hasattr(e, "response") and e.response is not None:
                logger.error(f"Response body: {e.response.text}")
            return None

        except Exception as e:
            logger.error(f"Unexpected error in call_service: {e}")
            return None

    async def health_check(self) -> bool:
        """Check if Home Assistant API is accessible.

        Returns:
            True if HA is reachable and authenticated, False otherwise
        """
        url = f"{self.base_url}/api/"

        try:
            async with httpx.AsyncClient(timeout=5.0) as client:
                response = await client.get(url, headers=self._get_headers())
                response.raise_for_status()

            data = response.json()
            logger.info(f"Home Assistant health check OK: {data.get('message')}")
            return True

        except httpx.HTTPError as e:
            logger.error(f"Home Assistant health check failed: {e}")
            return False

        except Exception as e:
            logger.error(f"Unexpected error in health check: {e}")
            return False
